#!/usr/bin/env groovy
import hudson.tasks.test.AbstractTestResultAction
TARGET_LIST = TARGET_LIST.split("\n")
def HOTFIX_LIST = TARGET_LIST
println "Input ${TARGET_LIST}"

def total_hotfix_errata = HOTFIX_LIST.length
println "Length ${total_hotfix_errata}"

String[] ARM_IMAGES = [ "RedHat RHEL 6.7 Latest", "RedHat RHEL 6.8 Latest", "RedHat RHEL 6.9 Latest",
			"RedHat RHEL 6.10 Latest", "RedHat RHEL 7.2 Latest", "RedHat RHEL 7.3 Latest",
			"RedHat RHEL 7.4 Latest", "RedHat RHEL 7.5 Latest", "RedHat RHEL 7-RAW 7.6.2018103108",
			"OpenLogic CentOS 6.5 Latest", "OpenLogic CentOS 6.6 Latest", "OpenLogic CentOS 6.7 Latest",
			"OpenLogic CentOS 6.8 Latest", "OpenLogic CentOS 6.9 Latest", "OpenLogic CentOS 6.10 Latest", 
			"OpenLogic CentOS 7.0 Latest", "OpenLogic CentOS 7.1 Latest", "OpenLogic CentOS 7.2 Latest",
			"OpenLogic CentOS 7.3 Latest", "OpenLogic CentOS 7.4 Latest", "OpenLogic CentOS 7.5 Latest",
			"OpenLogic CentOS 7.6 Latest", "Oracle Oracle-Linux 6.8 Latest", "Oracle Oracle-Linux 6.9 Latest",
			"Oracle Oracle-Linux 6.10 Latest", "Oracle Oracle-Linux 7.3 Latest", "Oracle Oracle-Linux 7.4 Latest",
			"Oracle Oracle-Linux 7.5 Latest", "Oracle Oracle-Linux 7.6 Latest" ]

def armImages = ["rhel_6.5": "OpenLogic CentOS 6.5 Latest", "rhel_6.6": "OpenLogic CentOS 6.6 Latest", "rhel_6.7": "OpenLogic CentOS 6.7 Latest", 
		 "rhel_6.8": "OpenLogic CentOS 6.8 Latest", "rhel_6.9": "OpenLogic CentOS 6.9 Latest", "rhel_6.10": "OpenLogic CentOS 6.10 Latest", 
		 "rhel_7.0": "OpenLogic CentOS 7.0 Latest", "rhel_7.1": "OpenLogic CentOS 7.1 Latest", "rhel_7.2": "OpenLogic CentOS 7.2 Latest", 
		 "rhel_7.3": "OpenLogic CentOS 7.3 Latest", "rhel_7.4": "OpenLogic CentOS 7.4 Latest", "rhel_7.5": "OpenLogic CentOS 7.5 Latest", 
		 "rhel_7.6": "OpenLogic CentOS 7.6 Latest"]

def HyperVImages = ["rhel_6.5": "rhel_6.5", "rhel_6.6": "rhel_6.6_x64", "rhel_6.7": "NA", 
			"rhel_6.8": "rhel_6.8_x64", "rhel_6.9": "rhel_6.9_x64", "rhel_6.10": "rhel_6.10_x64", 
			 "rhel_7.0": "rhel_7.0", "rhel_7.1": "rhel_7.1", "rhel_7.2": "rhel_7.2", 
			 "rhel_7.3": "rhel_7.3", "rhel_7.4": "rhel_7.4", "rhel_7.5": "rhel_7.5", 
			 "rhel_7.6": "rhel_7.6"]

def CUSTOM_KERNEL = null
def CUSTOM_LIS = null
def CUSTOM_LIS_ISO = null
def execution_tag = null
def hotfixlisVersion = null
def lis_old_url = null
def HYPERV_TESTS = "DYNAMIC-MEMORY-VERIFY-UDEV,DYNAMIC-MEMORY-HOT-ADD,FCOPY-BASIC,SQM-BASIC,KVP-INTRINSIC,KVP-KEY-VALUES-OPERATIONS,NET-EXTERNAL,NET-INTERNAL,NET-IP-INJECTION,NET-JUMBO-FRAMES,NET-VLAN-TAGGING,NET-VLAN-TRUNKING,NET-HOT-ADD-MULTINIC,NET-HOT-REMOVE-MULTINIC,ETHTOOL-CHECK-STATISTICS,PRODUCTION-CHECKPOINT,RUNTIME_MEM_HOTADD,RUNTIME_MEM_HOTREMOVE,STORAGE-VHDX-IDE-DYNAMIC,VHDX-RESIZE-GROW-FILESYSTEM-512,VHDX-RESIZE-GROW-FILESYSTEM-4096,VSS-BACKUPRESTORE-MULTIFS-VHDX,VERIFY-HEARTBEAT,VERIFY-VM-SHUTDOWN,TIMESYNC-HOST,MAX-VCPU,CHECK-NUMA,TIMESYNC-BASIC,VMBUS_VERIFY_PROTOCOL_VERSION,NMI_VERIFY_INTERRUPT,CHECK-NUMA-MAXIMUM"
def REDMOND_SHARE_PATH = '\\\\redmond\\wsscfs\\OSTC\\LIS\\LIS-Builds\\lisbuilds\\'
env.STORAGE_ACCOUNT_NAME = null

def total = -1
def failed = -1
def skipped = -1
def passed = -1

def RunPowershellCommand(psCmd) {
	bat "powershell.exe -NonInteractive -ExecutionPolicy Bypass -Command \"[Console]::OutputEncoding=[System.Text.Encoding]::UTF8;$psCmd;EXIT \$global:LastExitCode\""
	//println "powershell.exe -NonInteractive -ExecutionPolicy Bypass -Command \"[Console]::OutputEncoding=[System.Text.Encoding]::UTF8;$psCmd;EXIT \$global:LastExitCode\""
}

def Prepare() {
	retry(5) {
		cleanWs()
		unstash 'LISAv2'
	}
}

def CreateAzureVM(Distro, errata_kernel) {
	println "Entering creating Azure VM for distro ${Distro} errata_kernel ${errata_kernel}"
	println "Exiting creating Azure VM"
}

def getVersionFromURL(lisLink) {
	def realLink = ""
	def lisVer = ""
	if (lisLink.contains("tar.gz")){
		realLink = lisLink
	} else {
		realLink = sh (returnStdout: true, script: """
		curl -Ls -o /dev/null -w %{url_effective} "${lisLink}"
		""")
	}
	lisVer = realLink.split("/")
	println "lisVer $lisVer"
	return lisVer[lisVer.size() - 1].split(".tar.gz")[0]
}

def ReportException(stagename, exc) {
	def body = "<pre>"
	body += "\nStage Name        : ${stagename}\n"
	body += "\nException Message : ${exc}\n"
	body += "\nBuild URL         : ${env.BUILD_URL}\n"
	withCredentials([string(credentialsId: 'HOTFIX_DEV_MAIL', variable: 'HOTFIX_DEV_MAIL')]) {
	emailext (
		subject: "LIS-Hotfix-Pipeline BUILD:${env.BUILD_NUMBER} Exception",
		to: "${env.HOTFIX_DEV_MAIL}",
		mimeType : "text/html",
		body: body
		)
	}
}

def getErrataKernelLink(kernelversion) {
	node ("jenkins-meta-slave") {
		withCredentials([file(credentialsId: 'LIS_HOTFIX_CONFIGURE_FILE', variable: 'LIS_HOTFIX_CONFIGURE_FILE')]) {
			sh (returnStatus: true, script: """
				. ${LIS_HOTFIX_CONFIGURE_FILE}
				echo "\$LIS_HOTFIX_STORAGE_ACCOUNT" > storageblob.tmp
				""" )
		}
		def storageblob = readFile 'storageblob.tmp'
		storageblob = storageblob.replaceAll("\r", "").replaceAll("\n", "");
		env.STORAGE_ACCOUNT_NAME = storageblob
		println "${storageblob}"
		return "https://${storageblob}.blob.core.windows.net/kernel/${kernelversion}/kernel-${kernelversion}.x86_64.rpm"
	}
}

def checkerrataLink(errataLink) {
	def status = sh (returnStatus: true, script: """
		wget ${errataLink}
		""" )
	if ( status != 0) {
		throw new Exception("${errataLink} is unreachable.")
	}
}

def uploadrpmsToRedmond(lisversion, custom_lis, custom_lis_iso, destination_path) {
	node ("ws2016") {
		println "Running web request to copy file on redmond share"
		println "input lisversion ${lisversion} custom_lis ${custom_lis} iso ${custom_lis_iso}"
		RunPowershellCommand("\$WebClient = New-Object System.Net.WebClient;" +
			 "\$WebClient.DownloadFile('${custom_lis}','lis-rpms-${lisversion}-HotfixDemo.tar.gz');" +
			 "Copy-Item -Path lis-rpms-${lisversion}-HotfixDemo.tar.gz -Destination ${destination_path};"
			 )
		RunPowershellCommand("\$WebClient = New-Object System.Net.WebClient;" +
			 "\$WebClient.DownloadFile('${custom_lis_iso}','LinuxIC-${lisversion}-HotfixDemo.iso');" +
			 "Copy-Item -Path LinuxIC-${lisversion}-HotfixDemo.iso -Destination ${destination_path};"
		 )
	}
}

def SendReportEmail() {
	withCredentials([string(credentialsId: 'HOTFIX_MAIL_LIST', variable: 'HOTFIX_MAIL_LIST')]) {
		emailext (
			subject: "LIS-Hotfix-Pipeline: test results for ${TARGET_LIST}",
			to: "${env.HOTFIX_MAIL_LIST}",
			mimeType : "text/html",
			body: '${SCRIPT, template="ubuntu.template"}'
		)
	}
}

def IncrementMinorRevision(OldVersion) {
	def count = OldVersion.count(".")
	def newVersion = null
	if (count > 2)
	{
		def v = OldVersion
		println v
		String minor=v.substring(v.lastIndexOf('.')+1) //get last digit
		int m=minor.toInteger()+1                      //increment
		println m
		String major=v.substring(0,v.lastIndexOf("."));       //get the beginning
		println major
		newVersion = "${major}.${m}"
		println "newVersion ${newVersion}"
	} else {
		newVersion = "${OldVersion}.1"
	}
	return newVersion
}

def GetMajorVersion(InVersion) {
	def count = InVersion.count(".")
	def majorVersion = null
	if (count > 2) {
		def v = InVersion
		println v
		String major=v.substring(0,v.lastIndexOf("."));       //get the beginning
		println major
		majorVersion = "${major}"
	} else {
		majorVersion = "${InVersion}"
	}
	return majorVersion
}

//Hotfix timeout set to 24 hours
def hotfixTimeout = 24
node ("jenkins-meta-slave") {
	def currentStage = null
	try {
	timeout(time: hotfixTimeout, unit: 'HOURS') {
		currentStage = "Prerequisite"
		stage (currentStage) {
			cleanWs()
			git branch: env.GIT_BRANCH, url: env.GIT_REPO
			stash includes: '**', name: 'LISAv2'
			cleanWs()
			def distro = null
			def version = null
			for (i=0; i < total_hotfix_errata; i++) {
				distro = HOTFIX_LIST[i].split('=')[0]
				println distro
				version = HOTFIX_LIST[i].split('=')[1]
				println version
				CUSTOM_KERNEL = getErrataKernelLink("${version}")
				checkerrataLink("${CUSTOM_KERNEL}")
			}
			def body = ""
			body += "<br/>New non compatible errata kernel have been detected:<br/>"
			body += "${TARGET_LIST}<br/>"
			body += "<br/><br/>Build and Testing has been triggered. Click the below link to check the progress : <br/>"
			body += "${env.BUILD_URL}<br/><br/>"
			body += "Thank you,<br/>Jenkins CI"
			withCredentials([string(credentialsId: 'HOTFIX_MAIL_LIST', variable: 'HOTFIX_MAIL_LIST')]) {
			emailext (
				subject: "LIS-Hotfix-Pipeline: Non compatible errata kernel detected, build and test is triggered",
				to: "${env.HOTFIX_MAIL_LIST}",
				mimeType : "text/html",
				body: body
			)
			}
		}

		currentStage = "Prepare Environment"
		node ("azure") {
			stage (currentStage) {
				def distro = "${HOTFIX_LIST}"
				println "distro ${distro}"
				distro = distro.replace('[', '')
				distro = distro.replace(']', '')
				distro = distro.replace(' ', '')
				println "distro ${distro}"
				checkout scm
				withCredentials([file(credentialsId: 'Azure_Secrets_File', variable: 'Azure_Secrets_File'), string(credentialsId: 'LIS_BUILD_PASSWORD', variable: 'LIS_BUILD_PASSWORD')]) 
				{
					RunPowershellCommand(".\\scripts\\lis_hotfix_pipeline\\CreateBuildMachines.ps1"+
						" -DistroKernelVersions '${distro}'" +
						" -VHDSourceStorageAccount '${env.STORAGE_ACCOUNT_NAME}'" +
						" -bootstorageName 'bootdiag000004'" +
						" -secretsFile '${Azure_Secrets_File}' "
					)
				}
				println "Build Environment created successfully"
			}
		}

		currentStage = "Hotfix Build RPM"
		node ("azure") {
			stage (currentStage) {
				
				try {
					node ("azure") {
						println "In this stage invoke Build pipeline"
						def newVersion = ""
						def LIS_LINK = "http://aka.ms/lis"
						def lisVersion = getVersionFromURL(LIS_LINK)
						println "LIS Version: ${lisVersion} LINK ${LIS_LINK}"
						def OldVersion = lisVersion.split('rpms-')[1]
						println "OLD Version: ${OldVersion} LINK ${LIS_LINK}"

						lis_old_url = sh (returnStdout: true, script: """
								curl -Ls -o /dev/null -w %{url_effective} "${LIS_LINK}"
								""")
						println "OLD URL link ${lis_old_url}"
						def branchName = GetMajorVersion("${OldVersion}")
						hotfixlisVersion = IncrementMinorRevision("${OldVersion}")
						println "hotfixlisVersion ${hotfixlisVersion}"
						println "pipeline-lis-rpm-build-demo is invoked .. "
						JobBuildRPM = build job: 'LIS/pipeline-lis-rpm-build-azure', parameters: [
						string(name: 'distro', value: "all"),
						string(name: 'build_rpm_source', value: "https://github.com/lis/lis-rpm-build-pipeline.git"),
						string(name: 'build_rpm_source_branch', value: "master"),
						string(name: 'buildname', value: "${hotfixlisVersion}"),
						string(name: 'source', value: "https://github.com/LIS/lis-next"),
						string(name: 'branch', value: "${branchName}"),
						string(name: 'RESOURCE_GROUP_NAME', value: "ss-lis-build-4")
						],
						quietPeriod: 10, wait: true, propagate: false
						
						copyArtifacts(projectName: 'LIS/pipeline-lis-rpm-build-demo', selector: specific("${JobBuildRPM.id}"));
						def customlisrpm = readFile 'LIS_RPM_URL.txt'
						def customlisiso = readFile 'LIS_ISO_URL.txt'
						println "customlisrpm ${customlisrpm} customlisiso ${customlisiso}"
						CUSTOM_LIS = "${customlisrpm}"
						CUSTOM_LIS_ISO = "${customlisiso}"
						}
					}catch (exc) {
						currentBuild.result = 'FAILURE'
						println exc
						ReportException("${currentTest}", "${exc}")
					} finally {
						cleanWs()
					}

					//Notify the Build stage successful
					withCredentials([string(credentialsId: 'HOTFIX_DEV_MAIL', variable: 'HOTFIX_DEV_MAIL')]) {
					emailext (
						subject: "LIS-Hotfix-Pipeline: Notification",
						to: "${env.HOTFIX_DEV_MAIL}",
						mimeType : "text/html",
						body: 'Notification: Build is successful and RPM is created for ${TARGET_LIST}'
						)
					}
			}
		}

		node ("azure") {
			currentStage = "Hotfix LIS Test"
			def parellel_jobs = [:]
			def delay = 0
			execution_tag = "${hotfixlisVersion}-Hotfix"
			stage ("${currentStage}") {
				for (i=0; i < total_hotfix_errata; i++) {
					println "In staging to run pipelines...."
					def distro = HOTFIX_LIST[i].split('=')[0]
					println distro
					def version = HOTFIX_LIST[i].split('=')[1]
					println version
					def errata_kernel = getErrataKernelLink("${version}")
					println errata_kernel
					def currentTest = "FunctionalTest-${distro}-${version}"
					parellel_jobs ["${currentTest}"] =
					{
						stage ("${currentTest}") {
							try {
								node ("azure") {
									delay += 5
									println "Sleeping ${delay} seconds..."
									sleep "${delay}"
									println "HotfixFunctionalTest pipeline is invoked for CUSTOM_LIS ${CUSTOM_LIS} , CUSTOM_KERNEL ${CUSTOM_KERNEL} "
									println ("Entering TriggerLISHotfixFunctionalTestPipeline")
									JobBuild = build job: 'LIS/pipeline-azure-lis-hotfix-functional-validation', parameters: [
									string(name: 'rpmURL', value: "${CUSTOM_LIS}"),
									string(name: 'testDistro', value: "${distro}"),
									string(name: 'ExecutionTag', value: "${execution_tag}"),
									string(name: 'LISoldurl', value: "LatestLIS"),
									string(name: 'CUSTOM_KERNEL', value: "${errata_kernel}")
									],
									quietPeriod: 10, wait: true, propagate: false
									println "Copy artifacts from hotfix-functional JobId ${JobBuild.id}"
									copyArtifacts(projectName: 'LIS/pipeline-azure-lis-hotfix-functional-validation', selector: specific("${JobBuild.id}"));
									println "junit final Report"
									junit "Report\\*-junit.xml"
								}
							}catch (exc) {
								currentBuild.result = 'SUCCESS'
								println exc
								ReportException("${currentTest}", "${exc}")
							} finally {
								cleanWs()
							}
						}
					}
					currentTest = "PerformanceTest-${distro}-${version}"
					parellel_jobs ["${currentTest}"] =
					{
						stage ("${currentTest}") {
							try {
								node ("azure") {
									delay += 5
									println "Sleeping ${delay} seconds..."
									sleep "${delay}"
									println "HotfixPerformanceTest pipeline is invoked:"
									PerfJob = build job: 'LIS/pipeline-azure-lis-hotfix-performance-validation', parameters: [
									string(name: 'rpmURL', value: "${CUSTOM_LIS}"),
									string(name: 'testDistro', value: "${distro}"),
									string(name: 'ExecutionTag', value: "${execution_tag}"),
									string(name: 'LISoldurl', value: "LatestLIS"),
									string(name: 'CUSTOM_KERNEL', value: "${errata_kernel}")
									],
									quietPeriod: 10, wait: true, propagate: false
									println "Copy artifacts from hotfix-performance JobId ${PerfJob.id}"
									copyArtifacts(projectName: 'LIS/pipeline-azure-lis-hotfix-performance-validation', selector: specific("${PerfJob.id}"));
									println "junit final Report"
									junit "Report\\*-junit.xml"
								}
							}catch (exc) {
								currentBuild.result = 'SUCCESS'
								println exc
								ReportException("${currentTest}", "${exc}")
							} finally {
								cleanWs()
							}
						}
					}
					currentTest = "HyperVTest-${distro}-${version}"
					parellel_jobs ["${currentTest}"] =
					{
						stage ("${currentTest}") {
							try {
								node ("azure") {
									delay += 5
									println "Sleeping ${delay} seconds..."
									sleep "${delay}"
									println "HyperVTest pipeline is invoked:"
									HyperVJob = build job: 'LIS/pipeline-lis-rpm-hyperv-lisav2-test', parameters: [
									string(name: 'DISTRO_VERSIONS', value: "${HyperVImages[distro]}"),
									string(name: 'LIS_ARCHIVE_LINK', value: "${CUSTOM_LIS}"),
									string(name: 'LIS_OLD_ARCHIVE_LINK', value: "LatestLIS"),
									string(name: 'RUN_SELECTED_TESTS', value: "${HYPERV_TESTS}"),
									string(name: 'EXECUTION_TAG', value: "${execution_tag}"),
									],
									quietPeriod: 10, wait: true, propagate: false
									println "Copy artifacts from hyperv-lisav2-test JobId ${HyperVJob.id}"
									copyArtifacts(projectName: 'LIS/pipeline-lis-rpm-hyperv-lisav2-test', selector: specific("${HyperVJob.id}"));
									println "junit final Report"
									junit "Report\\*-junit.xml"
								}
							}catch (exc) {
								currentBuild.result = 'SUCCESS'
								println exc
								ReportException("${currentTest}", "${exc}")
							} finally {
								cleanWs()
							}
						}
					}
				}
				parallel parellel_jobs
			}
		}

		currentStage = "Hotfix Result Extract"
		stage ("${currentStage}") {
			try {
				node ("azure") {
					def testStatus = ""
					AbstractTestResultAction testResultAction = currentBuild.rawBuild.getAction(AbstractTestResultAction.class)
					println "In this stage get the test result"
					if (testResultAction != null) {
						total = testResultAction.totalCount
						failed = testResultAction.failCount
						skipped = testResultAction.skipCount
						passed = total - failed - skipped
						testStatus = "Test Status:\n  Passed: ${passed}, Failed: ${failed} ${testResultAction.failureDiffString}, Skipped: ${skipped}"
						println "TestResult: ${testStatus}"
					}
				}
			} catch(exc) {
				currentBuild.result = 'FAILURE'
				println exc
				ReportException("${currentStage}", "${exc}")
			} finally {
				cleanWs()
			}
		}

		currentStage = "Hotfix RPM Upload"
		stage ("${currentStage}") {
			try {
				if (failed == 0) {
					println "Uploading the RPM to Redmond share"
					uploadrpmsToRedmond("${hotfixlisVersion}", "${CUSTOM_LIS}", "${CUSTOM_LIS_ISO}", "${REDMOND_SHARE_PATH}")
				}
				if (EMAIL_REPORT == 'true') {
					println "Send the Hotfix Test report"
					SendReportEmail()
				}
			} catch(exc) {
				currentBuild.result = 'FAILURE'
				println exc
				ReportException("${currentStage}", "${exc}")
			} finally {
				cleanWs()
			}
		}
	}
	} catch(exc) {
		currentBuild.result = 'FAILURE'
		println exc
		ReportException("${currentStage}", "${exc}")
	} finally {
		cleanWs()
	}
}
