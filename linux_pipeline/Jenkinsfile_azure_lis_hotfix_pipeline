#!/usr/bin/env groovy
import hudson.tasks.test.AbstractTestResultAction
TARGET_LIST = TARGET_LIST.split("\n")
def HOTFIX_LIST = TARGET_LIST
println "Input ${TARGET_LIST}"

def total_hotfix_errata = HOTFIX_LIST.length
println "Length ${total_hotfix_errata}"

String[] ARM_IMAGES = [ "RedHat RHEL 6.7 Latest", "RedHat RHEL 6.8 Latest", "RedHat RHEL 6.9 Latest",
			"RedHat RHEL 6.10 Latest", "RedHat RHEL 7.2 Latest", "RedHat RHEL 7.3 Latest",
			"RedHat RHEL 7.4 Latest", "RedHat RHEL 7.5 Latest", "RedHat RHEL 7-RAW 7.6.2018103108",
			"OpenLogic CentOS 6.5 Latest", "OpenLogic CentOS 6.6 Latest", "OpenLogic CentOS 6.7 Latest",
			"OpenLogic CentOS 6.8 Latest", "OpenLogic CentOS 6.9 Latest", "OpenLogic CentOS 6.10 Latest", 
			"OpenLogic CentOS 7.0 Latest", "OpenLogic CentOS 7.1 Latest", "OpenLogic CentOS 7.2 Latest",
			"OpenLogic CentOS 7.3 Latest", "OpenLogic CentOS 7.4 Latest", "OpenLogic CentOS 7.5 Latest",
			"OpenLogic CentOS 7.6 Latest", "Oracle Oracle-Linux 6.8 Latest", "Oracle Oracle-Linux 6.9 Latest",
			"Oracle Oracle-Linux 6.10 Latest", "Oracle Oracle-Linux 7.3 Latest", "Oracle Oracle-Linux 7.4 Latest",
			"Oracle Oracle-Linux 7.5 Latest", "Oracle Oracle-Linux 7.6 Latest" ]

def armImages = ["rhel_6.5": "OpenLogic CentOS 6.5 Latest", "rhel_6.6": "OpenLogic CentOS 6.6 Latest", "rhel_6.7": "OpenLogic CentOS 6.7 Latest", 
		 "rhel_6.8": "OpenLogic CentOS 6.8 Latest", "rhel_6.9": "OpenLogic CentOS 6.9 Latest", "rhel_6.10": "OpenLogic CentOS 6.10 Latest", 
		 "rhel_7.0": "OpenLogic CentOS 7.0 Latest", "rhel_7.1": "OpenLogic CentOS 7.1 Latest", "rhel_7.2": "OpenLogic CentOS 7.2 Latest", 
		 "rhel_7.3": "OpenLogic CentOS 7.3 Latest", "rhel_7.4": "OpenLogic CentOS 7.4 Latest", "rhel_7.5": "OpenLogic CentOS 7.5 Latest", 
		 "rhel_7.6": "OpenLogic CentOS 7.6 Latest"]

def HyperVImages = ["rhel_6.5": "rhel_6.5", "rhel_6.6": "rhel_6.6_x64", "rhel_6.7": "NA", 
			"rhel_6.8": "rhel_6.8_x64", "rhel_6.9": "rhel_6.9_x64", "rhel_6.10": "rhel_6.10_x64", 
			 "rhel_7.0": "rhel_7.0", "rhel_7.1": "rhel_7.1", "rhel_7.2": "rhel_7.2", 
			 "rhel_7.3": "rhel_7.3", "rhel_7.4": "rhel_7.4", "rhel_7.5": "rhel_7.5", 
			 "rhel_7.6": "rhel_7.6"]

//Added below definations for testing purpose
def CUSTOM_KERNEL = "https://lisbuildstorage04.blob.core.windows.net/kernel/kernel-3.10.0-862.34.1.el7.x86_64.rpm"
def CUSTOM_LIS = "https://linuxpipelineshare.blob.core.windows.net/lis-rpm-builds/lis-builds/lis-rpm-4.3.3-2019-06-08.10.36.tar.gz"
def CUSTOM_LIS_ISO = "https://linuxpipelineshare.blob.core.windows.net/lis-rpm-builds/lis-builds/lis-rpm-4.3.3-2019-06-08.10.38.iso"
def execution_tag = "Hotfix-test"
def hotfixlisVersion = "4.3.3.1"
def lis_old_url = "http://download.microsoft.com/download/6/8/F/68FE11B8-FAA4-4F8D-8C7D-74DA7F2CFC8C/lis-rpms-4.2.8-2.tar.gz"
def HYPERV_TESTS = "DYNAMIC-MEMORY-VERIFY-UDEV,DYNAMIC-MEMORY-HOT-ADD,FCOPY-BASIC,SQM-BASIC,KVP-INTRINSIC,KVP-KEY-VALUES-OPERATIONS,NET-EXTERNAL,NET-INTERNAL,NET-IP-INJECTION,NET-JUMBO-FRAMES,NET-VLAN-TAGGING,NET-VLAN-TRUNKING,NET-HOT-ADD-MULTINIC,NET-HOT-REMOVE-MULTINIC,ETHTOOL-CHECK-STATISTICS,PRODUCTION-CHECKPOINT,RUNTIME_MEM_HOTADD,RUNTIME_MEM_HOTREMOVE,STORAGE-VHDX-IDE-DYNAMIC,VHDX-RESIZE-GROW-FILESYSTEM-512,VHDX-RESIZE-GROW-FILESYSTEM-4096,VSS-BACKUPRESTORE-MULTIFS-VHDX,VERIFY-HEARTBEAT,VERIFY-VM-SHUTDOWN,TIMESYNC-HOST,MAX-VCPU,CHECK-NUMA,TIMESYNC-BASIC,VMBUS_VERIFY_PROTOCOL_VERSION,NMI_VERIFY_INTERRUPT,CHECK-NUMA-MAXIMUM"
def REDMOND_SHARE_PATH = '\\\\redmond\\wsscfs\\OSTC\\LIS\\LIS-Builds\\lisbuilds\\'

def total = -1
def failed = -1
def skipped = -1
def passed = -1

def RunPowershellCommand(psCmd) {
	bat "powershell.exe -NonInteractive -ExecutionPolicy Bypass -Command \"[Console]::OutputEncoding=[System.Text.Encoding]::UTF8;$psCmd;EXIT \$global:LastExitCode\""
	//println "powershell.exe -NonInteractive -ExecutionPolicy Bypass -Command \"[Console]::OutputEncoding=[System.Text.Encoding]::UTF8;$psCmd;EXIT \$global:LastExitCode\""
}

def Prepare() {
	retry(5) {
		cleanWs()
		unstash 'LISAv2'
	}
}

def CreateAzureVM(Distro, errata_kernel) {
	println "Entering creating Azure VM for distro ${Distro} errata_kernel ${errata_kernel}"
	println "Exiting creating Azure VM"
}

def getVersionFromURL(lisLink) {
	def realLink = ""
	def lisVer = ""
	if (lisLink.contains("tar.gz")){
		realLink = lisLink
	} else {
		realLink = sh (returnStdout: true, script: """
		curl -Ls -o /dev/null -w %{url_effective} "${lisLink}"
		""")
	}
	lisVer = realLink.split("/")
	println "lisVer $lisVer"
	return lisVer[lisVer.size() - 1].split(".tar.gz")[0]
}

def ReportException(stagename, exc) {
	def body = "<pre>"
	body += "\nStage Name        : ${stagename}\n"
	body += "\nException Message : ${exc}\n"
	body += "\nBuild URL         : ${env.BUILD_URL}\n"
	withCredentials([string(credentialsId: 'HOTFIX_DEV_MAIL', variable: 'HOTFIX_DEV_MAIL')]) {
	emailext (
		subject: "LIS-Hotfix-Pipeline BUILD:${env.BUILD_NUMBER} Exception",
		to: "${env.HOTFIX_DEV_MAIL}",
		mimeType : "text/html",
		body: body
		)
	}
}

def getErrataKernelLink(kernelversion) {
	node ("jenkins-meta-slave") {
		withCredentials([file(credentialsId: 'LIS_HOTFIX_CONFIGURE_FILE', variable: 'LIS_HOTFIX_CONFIGURE_FILE')]) {
			sh (returnStatus: true, script: """
				. ${LIS_HOTFIX_CONFIGURE_FILE}
				echo "\$LIS_HOTFIX_STORAGE_ACCOUNT" > storageblob.tmp
				""" )
		}
		def storageblob = readFile 'storageblob.tmp'
		storageblob = storageblob.replaceAll("\r", "").replaceAll("\n", "");
		println "${storageblob}"
		return "https://${storageblob}.blob.core.windows.net/kernel/${kernelversion}/kernel-${kernelversion}.x86_64.rpm"
	}
}

def checkerrataLink(errataLink) {
	def status = sh (returnStatus: true, script: """
		wget ${errataLink}
		""" )
	if ( status != 0) {
		throw new Exception("${errataLink} is unreachable.")
	}
}

def uploadrpmsToRedmond(lisversion, custom_lis, custom_lis_iso, destination_path) {
	node ("ws2016") {
		println "Running web request to copy file on redmond share"
		println "input lisversion ${lisversion} custom_lis ${custom_lis} iso ${custom_lis_iso}"
		RunPowershellCommand("\$WebClient = New-Object System.Net.WebClient;" +
			 "\$WebClient.DownloadFile('${custom_lis}','lis-rpms-${lisversion}-Hotfix.tar.gz');" +
			 "Copy-Item -Path lis-rpms-${lisversion}-Hotfix.tar.gz -Destination ${destination_path};"
			 )
		RunPowershellCommand("\$WebClient = New-Object System.Net.WebClient;" +
			 "\$WebClient.DownloadFile('${custom_lis_iso}','LinuxIC-${lisversion}-Hotfix.iso');" +
			 "Copy-Item -Path LinuxIC-${lisversion}-Hotfix.iso -Destination ${destination_path};"
		 )
	}
}

def SendReportEmail() {
	withCredentials([string(credentialsId: 'HOTFIX_MAIL_LIST', variable: 'HOTFIX_MAIL_LIST')]) {
		emailext (
			subject: "LIS-Hotfix-Pipeline: test results for ${TARGET_LIST}",
			to: "${env.HOTFIX_MAIL_LIST}",
			mimeType : "text/html",
			body: '${SCRIPT, template="ubuntu.template"}'
		)
	}
}

//Hotfix timeout set to 24 hours
def hotfixTimeout = 24
node ("jenkins-meta-slave") {
	def currentStage = null
	try {
	timeout(time: hotfixTimeout, unit: 'HOURS') {
		currentStage = "Prerequisite"
		stage (currentStage) {
			cleanWs()
			git branch: env.GIT_BRANCH, url: env.GIT_REPO
			stash includes: '**', name: 'LISAv2'
			cleanWs()
			def distro = null
			def version = null
			for (i=0; i < total_hotfix_errata; i++) {
				distro = HOTFIX_LIST[i].split('=')[0]
				println distro
				version = HOTFIX_LIST[i].split('=')[1]
				println version
				CUSTOM_KERNEL = getErrataKernelLink("${version}")
				checkerrataLink("${CUSTOM_KERNEL}")
			}
			def body = ""
			body += "<br/>New non compatible errata kernel have been detected:<br/>"
			body += "${TARGET_LIST}<br/>"
			body += "<br/><br/>Build and Testing has been triggered. Click the below link to check the progress : <br/>"
			body += "${env.BUILD_URL}<br/><br/>"
			body += "Thank you,<br/>Jenkins CI"
			withCredentials([string(credentialsId: 'HOTFIX_MAIL_LIST', variable: 'HOTFIX_MAIL_LIST')]) {
			emailext (
				subject: "LIS-Hotfix-Pipeline: Non compatible errata kernel detected, build and test is triggered",
				to: "${env.HOTFIX_MAIL_LIST}",
				mimeType : "text/html",
				body: body
			)
			}
		}

		currentStage = "Prepare Environment"
		node ("azure") {
			stage (currentStage) {
				def distro = HOTFIX_LIST[0].split('=')[0]
				println distro
				def version = HOTFIX_LIST[0].split('=')[1]
				println version
				CUSTOM_KERNEL = getErrataKernelLink("${version}")
				println "custom kernel link ${CUSTOM_KERNEL}"
				//This stage creates the VHD with hotfix errata and enviornment for Build pipeline
				println "Prepare environment stage"
				//this stage stashes the generated ips.sh
			}
		}

		currentStage = "Hotfix Build RPM"
		node ("azure") {
			stage (currentStage) {
				def Distros = [:]
				//Input to this stage is ips.sh
				println "In this stage invoke Build pipeline"

				//parameters: release_version,
				def LIS_LINK = "http://aka.ms/lis"
				def lisVersion = getVersionFromURL(LIS_LINK)
				println "LIS Version: ${lisVersion} LINK ${LIS_LINK}"
				//Remove lis-rpms from the version string
				def OldVersion = lisVersion.split('rpms-')[1]
				println "OLD Version: ${OldVersion} LINK ${LIS_LINK}"

				//Output from this stage is Built RPM tar.gz and iso file
				//Update CUSTOM_LIS and CUSTOM_LIS_ISO variable with downloadable links
				withCredentials([string(credentialsId: 'HOTFIX_DEV_MAIL', variable: 'HOTFIX_DEV_MAIL')]) {
				emailext (
					subject: "LIS-Hotfix-Pipeline: Notification",
					to: "${env.HOTFIX_DEV_MAIL}",
					mimeType : "text/html",
					body: 'Notification: Build is successful and RPM is created for ${TARGET_LIST}'
					)
				}

			}
		}

		node ("azure") {
			currentStage = "Hotfix LIS Test"
			def parellel_jobs = [:]
			def delay = 0
			execution_tag = "${hotfixlisVersion}-Hotfix"
			stage ("${currentStage}") {
				for (i=0; i < total_hotfix_errata; i++) {
					println "In staging to run pipelines...."
					def distro = HOTFIX_LIST[i].split('=')[0]
					println distro
					def version = HOTFIX_LIST[i].split('=')[1]
					println version
					def errata_kernel = getErrataKernelLink("${version}")
					println errata_kernel
					def currentTest = "FunctionalTest-${distro}-${version}"
					parellel_jobs ["${currentTest}"] =
					{
						stage ("${currentTest}") {
							try {
								node ("azure") {
									delay += 5
									println "Sleeping ${delay} seconds..."
									sleep "${delay}"
									println "HotfixFunctionalTest pipeline is invoked for CUSTOM_LIS ${CUSTOM_LIS} , CUSTOM_KERNEL ${CUSTOM_KERNEL} "
									println ("Entering TriggerLISHotfixFunctionalTestPipeline")
									JobBuild = build job: 'LIS/pipeline-azure-lis-hotfix-functional-validation', parameters: [
									string(name: 'rpmURL', value: "${CUSTOM_LIS}"),
									string(name: 'testDistro', value: "${distro}"),
									string(name: 'ExecutionTag', value: "${execution_tag}"),
									string(name: 'LISoldurl', value: "${lis_old_url}"),
									string(name: 'CUSTOM_KERNEL', value: "${errata_kernel}")
									],
									quietPeriod: 10, wait: true, propagate: false
									//JobId = TriggerLISHotfixFunctionalTestPipeline("${CUSTOM_LIS}","${distro}", "${execution_tag}", "${lis_old_url}", "${CUSTOM_KERNEL}", 10)
									println "Copy artifacts from hotfix-functional JobId ${JobBuild.id}"
									copyArtifacts(projectName: 'LIS/pipeline-azure-lis-hotfix-functional-validation', selector: specific("${JobBuild.id}"));
									println "junit final Report"
									junit "Report\\*-junit.xml"
								}
							}catch (exc) {
								currentBuild.result = 'SUCCESS'
								println exc
								ReportException("${currentTest}", "${exc}")
							} finally {
								cleanWs()
							}
						}
					}
					currentTest = "PerformanceTest-${distro}-${version}"
					parellel_jobs ["${currentTest}"] =
					{
						stage ("${currentTest}") {
							try {
								node ("azure") {
									delay += 5
									println "Sleeping ${delay} seconds..."
									sleep "${delay}"
									println "HotfixPerformanceTest pipeline is invoked:"
									PerfJob = build job: 'LIS/pipeline-azure-lis-hotfix-performance-validation', parameters: [
									string(name: 'rpmURL', value: "${CUSTOM_LIS}"),
									string(name: 'testDistro', value: "${distro}"),
									string(name: 'ExecutionTag', value: "${execution_tag}"),
									string(name: 'LISoldurl', value: "${lis_old_url}"),
									string(name: 'CUSTOM_KERNEL', value: "${errata_kernel}")
									],
									quietPeriod: 10, wait: true, propagate: false
									//TriggerLISHotfixPerformanceTestPipeline("${CUSTOM_LIS}","${armImages[distro]}", "${execution_tag}", "${lis_old_url}", "${CUSTOM_KERNEL}", 10)
									println "Copy artifacts from hotfix-performance JobId ${PerfJob.id}"
									copyArtifacts(projectName: 'LIS/pipeline-azure-lis-hotfix-performance-validation', selector: specific("${PerfJob.id}"));
									println "junit final Report"
									junit "Report\\*-junit.xml"
								}
							}catch (exc) {
								currentBuild.result = 'SUCCESS'
								println exc
								ReportException("${currentTest}", "${exc}")
							} finally {
								cleanWs()
							}
						}
					}
					currentTest = "HyperVTest-${distro}-${version}"
					parellel_jobs ["${currentTest}"] =
					{
						stage ("${currentTest}") {
							try {
								node ("azure") {
									delay += 5
									println "Sleeping ${delay} seconds..."
									sleep "${delay}"
									println "HyperVTest pipeline is invoked:"
									HyperVJob = build job: 'LIS/pipeline-lis-rpm-hyperv-lisav2-test', parameters: [
									string(name: 'DISTRO_VERSIONS', value: "${HyperVImages[distro]}"),
									string(name: 'LIS_ARCHIVE_LINK', value: "${CUSTOM_LIS}"),
									string(name: 'LIS_OLD_ARCHIVE_LINK', value: "${lis_old_url}"),
									string(name: 'RUN_SELECTED_TESTS', value: "${HYPERV_TESTS}"),
									string(name: 'EXECUTION_TAG', value: "${execution_tag}"),
									],
									quietPeriod: 10, wait: true, propagate: false
									println "Copy artifacts from hyperv-lisav2-test JobId ${HyperVJob.id}"
									copyArtifacts(projectName: 'LIS/pipeline-lis-rpm-hyperv-lisav2-test', selector: specific("${HyperVJob.id}"));
									println "junit final Report"
									junit "Report\\*-junit.xml"
								}
							}catch (exc) {
								currentBuild.result = 'SUCCESS'
								println exc
								ReportException("${currentTest}", "${exc}")
							} finally {
								cleanWs()
							}
						}
					}
				}
				parallel parellel_jobs
			}
		}

		currentStage = "Hotfix Result Extract"
		stage ("${currentStage}") {
			try {
				node ("azure") {
					def testStatus = ""
					AbstractTestResultAction testResultAction = currentBuild.rawBuild.getAction(AbstractTestResultAction.class)
					println "In this stage get the test result"
					if (testResultAction != null) {
						total = testResultAction.totalCount
						failed = testResultAction.failCount
						skipped = testResultAction.skipCount
						passed = total - failed - skipped
						testStatus = "Test Status:\n  Passed: ${passed}, Failed: ${failed} ${testResultAction.failureDiffString}, Skipped: ${skipped}"
						println "TestResult: ${testStatus}"
					}
				}
			} catch(exc) {
				currentBuild.result = 'FAILURE'
				println exc
				ReportException("${currentStage}", "${exc}")
			} finally {
				cleanWs()
			}
		}

		currentStage = "Hotfix RPM Upload"
		stage ("${currentStage}") {
			try {
				if (failed == 0) {
					println "Uploading the RPM to Redmond share"
					uploadrpmsToRedmond("${hotfixlisVersion}", "${CUSTOM_LIS}", "${CUSTOM_LIS_ISO}", "${REDMOND_SHARE_PATH}")
				}
				if (EMAIL_REPORT == 'true') {
					println "Send the Hotfix Test report"
					SendReportEmail()
				}
			} catch(exc) {
				currentBuild.result = 'FAILURE'
				println exc
				ReportException("${currentStage}", "${exc}")
			} finally {
				cleanWs()
			}
		}
	}
	} catch(exc) {
		currentBuild.result = 'FAILURE'
		println exc
		ReportException("${currentStage}", "${exc}")
	} finally {
		cleanWs()
	}
}
