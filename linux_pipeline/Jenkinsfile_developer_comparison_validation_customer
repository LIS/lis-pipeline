#!/usr/bin/env groovy

properties ([
    [$class: 'ParametersDefinitionProperty',
        parameterDefinitions: [
        [$class: 'ChoiceParameterDefinition',
            choices: 'git://git.kernel.org/pub/scm/linux/kernel/git/next/linux-next.git\nhttps://git.kernel.org/pub/scm/linux/kernel/git/davem/net-next.git\n',
            name: 'KERNEL_GIT_URL',
            description: 'Kernel tree repo'],
        [$class: 'StringParameterDefinition',
            name: 'KERNEL_GIT_BRANCH',
            defaultValue: 'master',
            description: 'Branch to be built'],
        [$class: 'StringParameterDefinition',
            defaultValue: '',
            name: 'KERNEL_PATCH',
            description: 'Valid examples: \n scp://my-scp-hostname:/home/my-username/patch.p1 \n scp://my-username@my-scp-hostname:/home/my-username/patch.p1 \n http://my-website.com/patch.p1 \n Use the space separator for multiple patches.'],
        [$class: 'BooleanParameterDefinition',
            defaultValue: false,
            name: 'SKIP_UNPATCHED',
            description: 'Skip unpatched kernel validation'],
        [$class: 'BooleanParameterDefinition', 
            defaultValue: true, 
            description: 'Azure VM boot test', 
            name: 'AZURE_BOOT'],
        [$class: 'ChoiceParameterDefinition',
            choices: "None\nkernel_pipeline_fvt.xml\nkernel_pipeline.bvt.xml\ntest_kernel_pipeline.xml",
            name: 'LISA_TEST_XML',
            description: 'Hyper-v functional validation type'],
        [$class: 'ChoiceParameterDefinition',
            choices: 'all\nCore (fvt)\nStorage (fvt)\nNetwork_and_Stress (fvt)\nMemory (fvt)',
            name: 'LISA_TEST_SUITE',
            description: 'Functional test suite'],
        ]
    ]
])

def createEnableStages(){
    env.ENABLED_STAGES = "build_artifacts, publish_temp_artifacts, publish_artifacts, validation, validation_functional,"
    if (AZURE_BOOT == "true") {
        env.ENABLED_STAGES += " boot_test,"
    }
    if (env.LISA_TEST_XML != "None") {
        env.ENABLED_STAGES +=  " validation_functional_hyperv,"
    }
}

createEnableStages()

node ("meta_slave") {
    def runs = [:]
    def patchedRun, unpachedRun;

    if (LISA_TEST_SUITE == 'all') {
        LISA_TEST_SUITE = ''
    } else {
        LISA_TEST_SUITE = LISA_TEST_SUITE.split(" ")[0].toLowerCase()
    }

    stage ("test_kernels") {
            runs["kernel_patched"] = {
                patchedRun = build job: "pipeline-developer-patch-validation/${env.BRANCH_NAME}", parameters: [
                    string(name: 'KERNEL_GIT_BRANCH', value: "${KERNEL_GIT_BRANCH}"),
                    string(name: 'KERNEL_GIT_URL', value: "${KERNEL_GIT_URL}"),
                    string(name: 'KERNEL_PATCH', value: "${KERNEL_PATCH}"),
                    string(name: 'CUSTOM_BUILD_TAG', value: "patched-${BUILD_NUMBER}"),
                    string(name: 'LISA_TEST_XML', value: "${LISA_TEST_XML}"),
                    string(name: 'LISA_TEST_SUITE', value: "${LISA_TEST_SUITE}"),
                    string(name: 'ENABLED_STAGES', value: "${ENABLED_STAGES}")], propagate: false;
            }
            if (env.SKIP_UNPATCHED == "false") {
                runs["kernel_unpatched"] = {
                    unpatchedRun = build job: "pipeline-developer-patch-validation/${env.BRANCH_NAME}", parameters: [
                        string(name: 'KERNEL_GIT_BRANCH', value: "${KERNEL_GIT_BRANCH}"),
                        string(name: 'KERNEL_GIT_URL', value: "${KERNEL_GIT_URL}"),
                        string(name: 'CUSTOM_BUILD_TAG', value: "unpatched-${BUILD_NUMBER}"),
                        string(name: 'LISA_TEST_XML', value: "${LISA_TEST_XML}"),
                        string(name: 'LISA_TEST_SUITE', value: "${LISA_TEST_SUITE}"),
                        string(name: 'ENABLED_STAGES', value: "${ENABLED_STAGES}")], propagate: false;
                }
            }
            parallel runs
    }

    stage ("aggregate_results") {
        dir ('aggregate_results' + env.BUILD_NUMBER + env.BRANCH_NAME) {
            copyArtifacts(projectName: "pipeline-developer-patch-validation/${env.BRANCH_NAME}", selector: specific("${patchedRun.number}"), target: "patched_run");
            archiveArtifacts 'patched_run/**';
            if (env.SKIP_UNPATCHED == "false") {
                copyArtifacts(projectName: "pipeline-developer-patch-validation/${env.BRANCH_NAME}", selector: specific("${unpatchedRun.number}"), target: "unpatched_run");
                archiveArtifacts 'unpatched_run/**';
                if (env.ENABLED_STAGES.contains("validation_functional_hyperv")) {
                    stash includes: 'patched_run/*-functional/TestResults/**/Report*.xml', name: 'patchedReport'
                    stash includes: 'unpatched_run/*-functional/TestResults/**/Report*.xml', name: 'unpatchedReport'
                }
                stash includes: 'unpatched_run/scripts/package_building/kernel_versions.ini', name: 'Metadata'
            } else {
                if (env.ENABLED_STAGES.contains("validation_functional_hyperv")) {
                    stash includes: 'patched_run/*-functional/TestResults/**/Report*.xml', name: 'patchedReport'
                }
                stash includes: 'patched_run/scripts/package_building/kernel_versions.ini', name: 'Metadata'
            }
        }
    }

    stage ("compare_results") {
        dir('comparison_results' + env.BUILD_NUMBER + env.BRANCH_NAME) {
            checkout scm
            unstash 'Metadata'
            if (env.ENABLED_STAGES.contains("validation_functional_hyperv")){
                env.FUNC_RUN = "true"
            } 
            sh '''#!/bin/bash
                INI_PATH="./unpatched_run/scripts/package_building/kernel_versions.ini"
                if [[ ! -e "$INI_PATH" ]];then
                    INI_PATH="./patched_run/scripts/package_building/kernel_versions.ini"
                fi
                META_PATH="./metadata.ini"
                KERNEL="$(crudini --get $INI_PATH KERNEL_BUILT folder)"
                KERNEL="${KERNEL%-unpatched*}"
                crudini --set $META_PATH 'METADATA' KERNEL_VERSION $KERNEL
                BRANCH="$(crudini --get $INI_PATH KERNEL_BUILT branch)"
                crudini --set $META_PATH 'METADATA' BRANCH $BRANCH
                crudini --set $META_PATH 'METADATA' LISA_XML $LISA_TEST_XML
                if [[ ${FUNC_RUN} == "true" ]];then
                    crudini --set $META_PATH 'METADATA' LISA_TEST_SUITE $LISA_TEST_SUITE
                fi
            '''

            PARSE_PARAMS = ""
            if (env.SKIP_UNPATCHED == "false") {
                if (env.ENABLED_STAGES.contains("validation_functional_hyperv")) {
                    unstash 'patchedReport'
                    unstash 'unpatchedReport'
                    PARSE_PARAMS += " --func_path ./patched_run/*-functional/TestResults/**/Report*.xml"
                    PARSE_PARAMS += " --func_comp_path ./unpatched_run/*-functional/TestResults/**/Report*.xml"
                }
            } else {
                if (env.ENABLED_STAGES.contains("validation_functional_hyperv")) {
                    unstash 'patchedReport'
                    PARSE_PARAMS += " --func_path ./patched_run/*-functional/TestResults/**/Report*.xml"
                }
            }
            println (PARSE_PARAMS)
            sh "bash ./scripts/comparison/create_report.sh ${PARSE_PARAMS} --metadata_path './metadata.ini' --output ./results.html"

            archiveArtifacts 'results.html'
            stash includes: 'results.html', name: 'report_results'
        }
    }

    stage ("Send Report"){
        node ("jenkins-meta-slave") {
            dir ("mail-send-comp-${env.BUILD_NUMBER}-${env.BRANCH_NAME}") {
                unstash 'report_results'
                mailBody = "Hello,</br></br>\nDeveloper Patch Validation Pipeline #${env.BUILD_NUMBER} is completed.</br>\n"
                if (env.KERNEL_PATCH != '') {
                    mailBody += "The following patches were applied:</br>\n"
                    patches = env.KERNEL_PATCH.split(" ")
                    patches.each(){
                        mailBody += it + "</br>\n"
                    }
                }
                mailBody += "</br>Testing results:</br></br>\n"
                mailBody += readFile("results.html")
                mailBody += "\n</br></br>Thank You,</br>Jenkins CI</br>\n"
                emailext (
                    subject: "Developer patch validation report for run:${env.BUILD_NUMBER}.",
                    recipientProviders: [[$class: 'RequesterRecipientProvider']],
                    mimeType : "text/html",
                    body: mailBody
                )
                deleteDir()
            }
        }
    }
}
